// Code generated by genny. DO NOT EDIT.
// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/mauricelam/genny

package writer

import "github.com/signalfx/golib/datapoint"

// nolint: dupl

import (
	"context"
	"sync/atomic"
)

// DatapointPreprocessor is used to filter out or otherwise change datapoints
// before being sent.  If the return value is false, the datapoint won't be
// sent.
type DatapointPreprocessor func(*datapoint.Datapoint) bool

// DatapointSender is what sends a slice of datapoints.  It should block until
// the datapoints have been sent, or an error has occurred.
type DatapointSender func(context.Context, []*datapoint.Datapoint) error

// DatapointRingWriter is an abstraction that accepts a bunch of datapoints,
// buffers them in a ring buffer and sends them out in batches.
type DatapointRingWriter struct {
	inputChan    chan *datapoint.Datapoint
	shutdownFlag chan struct{}

	preprocessFunc DatapointPreprocessor
	sendFunc       DatapointSender

	MaxBuffered  int
	MaxRequests  int
	MaxBatchSize int

	requestsActive  int64
	requestsWaiting int64
	totalWaiting    int64

	totalReceived           int64
	totalFilteredOut        int64
	totalInFlight           int64
	totalSent               int64
	totalFailedToSend       int64
	totalPotentiallyDropped int64
}

// NewDatapointRingWriter returns an initialized but not running datapoint of the
// DatapointRingWriter. You must call Run on the returned datapoint for it to work.
// preprocessFunc can be used for filtering or modifying datapoints before
// being sent.  If preprocessFunc returns false, the datapoint will not be
// sent.  preprocessFunc can be nil, in which case all datapoints will be sent.
// sendFunc must be provided as the writer is useless without it.
func NewDatapointRingWriter(preprocessFunc DatapointPreprocessor, sendFunc DatapointSender) *DatapointRingWriter {
	return &DatapointRingWriter{
		// Give the input channel a bit of buffer, but in general the writer
		// should be pulling off of it faster than datapoints would normally be
		// generated.
		inputChan:      make(chan *datapoint.Datapoint, 1000),
		preprocessFunc: preprocessFunc,
		sendFunc:       sendFunc,

		MaxBuffered:  10000,
		MaxRequests:  10,
		MaxBatchSize: 1000,
	}
}

// InputChan returns the channel that should be used to send datapoints to this
// writer.
func (w *DatapointRingWriter) InputChan() chan *datapoint.Datapoint {
	return w.inputChan
}

func (w *DatapointRingWriter) WaitForShutdown() {
	if w.shutdownFlag == nil {
		panic("should not wait for writer shutdown when not running")
	}
	<-w.shutdownFlag
}

// Run waits for things to come in on the provided
// channels and forwards them to SignalFx.  This function blocks until the
// provided context is finished.
// nolint: dupl
func (w *DatapointRingWriter) Run(ctx context.Context) {
	w.shutdownFlag = make(chan struct{})
	defer func() {
		close(w.shutdownFlag)
	}()

	bufferSize := w.MaxBuffered
	// Ring buffer of datapoints, initialized to its maximum length to avoid
	// reallocations.
	buffer := make([]*datapoint.Datapoint, bufferSize)
	// The index that marks the end of the last chunk of datapoints that was
	// sent.  It is one greater than the actual index, to match the golang
	// slice high range.
	lastHighStarted := 0
	// The next index within the buffer that a datapoint should be added to.
	nextDatapointIdx := 0
	// Corresponds to nextDatapointIdx but is easier to work with without modulo
	batched := 0
	requestDoneCh := make(chan int64, w.MaxRequests)

	// How many times around the ring buffer we have gone when putting
	// datapoints onto the buffer
	bufferedCircuits := int64(0)
	// How many times around the ring buffer we have gone when starting
	// requests
	startedCircuits := int64(0)

	targetHighStarted := func() int {
		if nextDatapointIdx < lastHighStarted {
			// Wrap around happened, just take what we have left until wrap
			// around so that we can take a single slice of it since slice
			// ranges can't wrap around.
			return bufferSize
		}

		return nextDatapointIdx
	}

	tryToSendBufferChunk := func(newHigh int) bool {
		if newHigh == lastHighStarted { // Nothing added
			return false
		}

		if w.requestsActive >= int64(w.MaxRequests) {
			w.requestsWaiting++
			w.totalWaiting += int64(newHigh - lastHighStarted)
			return false
		}

		count := int64(newHigh - lastHighStarted)
		w.totalInFlight += count
		w.requestsActive++

		go func(low, high int) {
			err := w.sendFunc(ctx, buffer[low:high])
			if err != nil {
				atomic.AddInt64(&w.totalFailedToSend, count)
			} else {
				atomic.AddInt64(&w.totalSent, count)
			}

			requestDoneCh <- count
		}(lastHighStarted, newHigh)

		lastHighStarted = newHigh
		if lastHighStarted == bufferSize { // Wrap back to 0
			lastHighStarted = 0
			startedCircuits++
		}

		batched = 0
		w.requestsWaiting = 0
		w.totalWaiting = 0
		return true
	}

	handleRequestDone := func(count int64) {
		w.requestsActive--
		w.totalInFlight -= count
		if w.requestsWaiting > 0 {
			tryToSendBufferChunk(targetHighStarted())
		}
	}

	process := func(inst *datapoint.Datapoint) {
		w.totalReceived++

		if w.preprocessFunc != nil && !w.preprocessFunc(inst) {
			w.totalFilteredOut++
			return
		}

		buffer[nextDatapointIdx] = inst

		if lastHighStarted-1-int(w.totalInFlight) < nextDatapointIdx && bufferedCircuits > startedCircuits {
			w.totalPotentiallyDropped++
		}
		batched++

		nextDatapointIdx++
		if nextDatapointIdx == bufferSize { // Wrap around the buffer
			nextDatapointIdx = 0
			bufferedCircuits++
		}

		if batched >= w.MaxBatchSize {
			tryToSendBufferChunk(targetHighStarted())
		}
	}

	waitForRequests := func() {
		for w.requestsActive > 0 {
			select {
			case count := <-requestDoneCh:
				handleRequestDone(count)
			}
		}
	}

	flush := func() {
		newHigh := targetHighStarted()
		// Could be less if wrapped around
		if newHigh != lastHighStarted {
			tryToSendBufferChunk(newHigh)
		}
	}

	drainInput := func() {
		defer waitForRequests()
		defer flush()
		for {
			select {
			case inst := <-w.inputChan:
				process(inst)
			default:
				return
			}
		}
	}

	for {
		select {
		case <-ctx.Done():
			drainInput()
			return

		case inst := <-w.inputChan:
			process(inst)

		case count := <-requestDoneCh:
			handleRequestDone(count)

		default:
			flush()

			select {
			case <-ctx.Done():
				drainInput()
				return

			case count := <-requestDoneCh:
				handleRequestDone(count)

			case inst := <-w.inputChan:
				process(inst)
			}
		}
	}
}
